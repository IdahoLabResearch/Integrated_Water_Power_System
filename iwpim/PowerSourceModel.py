import sys
import os 
import copy
from operator import itemgetter
import collections
from collections import Counter
from copy import deepcopy

from pypdevs.DEVS import *
from pypdevs.infinity import INFINITY
import random

from Functions import *

from operator import add

import numpy as np
import pylab 


class PowerSource(AtomicDEVS): 
    #Each power source is characterized by those parameters
	def __init__(self, name=None, zone = None): 
	#def __init__(self, name=None, mode ): #Add characteristics of the generator
      
		# Always call parent class' constructor FIRST:
		AtomicDEVS.__init__(self, name)
		#AtomicDEVS.__init__(self, name, mode)
		
		
  
  #Initialization of all variables of the class 
		self.state = "idle" #initial state
		self.elapsed = 0
		self.name = name #Name of the source
		self.zone = zone 
		
		#A dictionary specifying name and the capacity for usage of the utility {'name':'generator_name', 'capacity': quantity}
		self.supply = {}
		self.supply['name'] = self.name
		#self.supply.update({'cost':getCost(self.name)})  
		self.supply['cost'] = getCost(self.name) 
		self.supply['technology'] = getSupplyType(self.name)

		self.waterUsed = 0 #Amount of water used
		self.waterUsedList = [] #track the amount of water used to update capacity 

		#Get the forecast demand 	
		#file_path = r'C:/Users/TOBAD/OneDrive - Idaho National Laboratory/INL_PROJECTS/WPTO PRojects/FY21/Model_LatestVersion'
		file_path = r'C:/Users/TOBAD/OneDrive - Idaho National Laboratory/INL_PROJECTS/WPTO Projects/FY21/Model_LatestVersion'

		os.chdir(file_path)
		forecasted = file_path + r'/Data/powerForecastDemand.csv'

		self.powerForecastDemand = readPowerDemand(forecasted) 

		self.total_time = 0 #simulation time 
		self.totaltime_value = [] #simulation time 
		self.powerGenerated = []
		self.sourceUsed = {}

		# Water capacity to deliver power 
		self.supply['waterCapacity'] = PowerSourceCapacity(self.name) * WaterForPower(self.name) 


		#Graph variables --------------------------------------
		self.hydroPowersupplied_value = []	
		self.gridPowersupplied_value = []	
		self.hydroPowersupplied = []
		self.gridPowersupplied = [] 
		#-------------------------------------------------------
		
		#Input and output of the class ----------------------------------------------------------------------------------
		#output message sent by the agent
		self.PowerToDeliver = self.addOutPort(name="PowerToDeliver") #amount of power avaialable to meet demand 
		#input message received by the agent
		self.PowerSupplyUsed = self.addInPort(name="PowerSupplyUsed") #amount of power resource used
		
		
	def extTransition(self, inputs):
	#External Transition Function, defining state change after receiving input from another class
		self.total_time += self.elapsed 	
		
		#Message from the Dispatcher, specifying the resources utilized
		powerSupplyUsed = inputs.get(self.PowerSupplyUsed)

		if self.state == "wait" and powerSupplyUsed != None:
			#Compute the % of resource used 
			self.powerSupplyUsed = powerSupplyUsed # List of all sources and total supply avaialable
			for sply  in self.powerSupplyUsed[0][0]:
				#Make sure the locations match
				if sply.get('name') == self.name: 
					self.sourceUsed = {'zone': self.name,'quantity': sply.get('quantity'), 'Used': float(sply.get('quantity')/self.supply['quantity'])} #Power demand met 
					break 

			#Lists of the amount of demands met, per demand type 
			self.state = "advance"
		else:
			print ("ERROR in demand Atomic model EXTERNAL TRANSITION FUNCTION, ZONE : __ %s") %self.zone
		
		return self.state 

		
	def intTransition(self):
	#Internal Transition Function, defining state change internally
		self.total_time += self.timeAdvance()

		if self.state == "idle":
			self.state = "supply"

		elif self.state == "supply":
			self.state = "wait"
		
		elif self.state == "advance":
			self.state = "idle"

		else:		
			print ("ERROR in power  supply Atomic model INTERNAL TRANSITION FUNCTION")
		return self.state

							
	def outputFnc(self):
	# Output Funtion, specifying the output to send to the dispatcher

		#Graph
		##################################################
		self.hydroPowersupplied_value.append(getHydroPower(self.name)[int(self.total_time)%180])
		self.totaltime_value.append(self.total_time)
		####################################


		if self.state == "supply" :
			if getSupplyType(self.name) == 'Hydro': #power generated by Hydro
				self.powerGenerated = getHydroPower(self.name)
				self.supply['waterCapacity'] -= self.powerGenerated[int(self.total_time)%180]
		
			
			if getSupplyType(self.name) == 'Gas': #power generated by Gas
				self.powerGenerated = [PowerSourceCapacity(self.name) * x for x in list(self.powerForecastDemand.values())[0]]
			
			# if getSupplyType(self.name) == 'Nuclear': #power generated by hydro
				# self.powerGenerated = [PowerSourceCapacity(self.name) * x for x in self.powerForecastDemand]	
			
			self.supply['quantity'] = float(self.powerGenerated[int(self.total_time)%180])
			
			# Power supplied 
			return {self.PowerToDeliver: [copy.copy(self.supply)]} 
		
		else:
			return {}
			
			
	def timeAdvance(self):
	# Time advanse function
		if self.state == "advance" :   
			return 1
		#elif self.state == "supply" or self.state == "idle" or self.state == "wait":  
		elif self.state == "supply" or self.state == "idle" :  
			return 0 
		elif self.state == "wait":
			return INFINITY	
		else:

			raise DEVSException(\
				"unknown state <%s> in power  Atomic model ADVANCE FUNCTION"\
				% self.state)
				
